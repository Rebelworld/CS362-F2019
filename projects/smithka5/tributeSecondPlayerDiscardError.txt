GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-110.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /nfs/stak/users/shabazzm/class362/assign5/unittest5...done.
(gdb) break 53
Breakpoint 1 at 0x401100: file unittest5.c, line 53.
(gdb) run
Starting program: /nfs/stak/users/shabazzm/class362/assign5/unittest5
warning: the debug information found in "/usr/lib/debug//lib64/ld-2.17.so.debug" does not match "/lib64/ld-linux-x86-64.so.2" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug/usr/lib64/ld-2.17.so.debug" does not match "/lib64/ld-linux-x86-64.so.2" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug//usr/lib64/ld-2.17.so.debug" does not match "/lib64/ld-linux-x86-64.so.2" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug/usr/lib64//ld-2.17.so.debug" does not match "/lib64/ld-linux-x86-64.so.2" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug//lib64/libm-2.17.so.debug" does not match "/lib64/libm.so.6" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug/usr/lib64/libm-2.17.so.debug" does not match "/lib64/libm.so.6" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug//usr/lib64/libm-2.17.so.debug" does not match "/lib64/libm.so.6" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug/usr/lib64//libm-2.17.so.debug" does not match "/lib64/libm.so.6" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug//lib64/libc-2.17.so.debug" does not match "/lib64/libc.so.6" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug/usr/lib64/libc-2.17.so.debug" does not match "/lib64/libc.so.6" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug//usr/lib64/libc-2.17.so.debug" does not match "/lib64/libc.so.6" (CRC mismatch).

warning: the debug information found in "/usr/lib/debug/usr/lib64//libc-2.17.so.debug" does not match "/lib64/libc.so.6" (CRC mismatch).

TESTING Card Test 5: TRIBUTE:


Breakpoint 1, main () at unittest5.c:54
54          for(int i=0; i<testG.handCount[1]; i++)
Missing separate debuginfos, use: debuginfo-install glibc-2.17-292.el7.x86_64
(gdb) p testG.handCount[1]
$1 = 0
(gdb) p testG.handCount[0]
$2 = 5
(gdb) p testG.discardCount[1]
$3 = 0
(gdb) p testG. discardCount[0]
$4 = 0
(gdb) set testG.handCount[1]=2
(gdb) p testG.handCount[1]]
Junk after end of expression.
(gdb) p testG.handCount[1]
$5 = 2
(gdb) set testG.hand[1][0]=silver
(gdb) p testG.hand[1][0]
$6 = 5
(gdb) p testG.hand[1][1]
$7 = 0
(gdb) set testG.hand[1][1]=silver
(gdb) s
56              testG.hand[1][i]=silver;
(gdb) s
54          for(int i=0; i<testG.handCount[1]; i++)
(gdb) s
56              testG.hand[1][i]=silver;
(gdb) s
54          for(int i=0; i<testG.handCount[1]; i++)
(gdb) s
58          int coinsPre=testG.coins;
(gdb) s
59          tributeEffect(&testG,currentPlayer,1);
(gdb) s
tributeEffect (state=0x7fffffff11e0, currentPlayer=0, nextPlayer=1)
    at dominion.c:863
863         int tributeRevealedCards[2] = {-1,-1};
(gdb) s
864         if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1) {
(gdb) s
882                 if (state->deckCount[nextPlayer] == 0) {
(gdb) s
892                 tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
(gdb) s
893                 state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
(gdb) s
894                 state->deckCount[nextPlayer]--;
(gdb) s
895                 tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
(gdb) s
896                 state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
(gdb) s
897                 state->deckCount[nextPlayer]--;
(gdb) s
900             if (tributeRevealedCards[0] == tributeRevealedCards[1]) { //If we have a duplicate card, just drop one
(gdb) s
906             for (int i = 0; i <= 2; i ++) {
(gdb) s
907                 if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
(gdb) s
908                     state->coins += 2;
(gdb) s
906             for (int i = 0; i <= 2; i ++) {
(gdb) s
907                 if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
(gdb) s
911                 else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) { //Victory Card Found
(gdb) s
912                     drawCard(currentPlayer, state);
(gdb) s
drawCard (player=0, state=0x7fffffff11e0) at dominion.c:566
566         if (state->deckCount[player] <= 0) { //Deck is empty
(gdb) s
606             int count = state->handCount[player];//Get current hand count for player
(gdb) s
612             deckCounter = state->deckCount[player];//Create holder for the deck count
(gdb) s
613             state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
(gdb) s
614             state->deckCount[player]--;
(gdb) s
615             state->handCount[player]++;//Increment hand count
(gdb) s
618         return 0;
(gdb) s
619     }
(gdb) p testG.hand[1][0]
No symbol "testG" in current context.
(gdb) s
tributeEffect (state=0x7fffffff11e0, currentPlayer=0, nextPlayer=1)
    at dominion.c:913
913                     drawCard(currentPlayer, state);
(gdb) s
drawCard (player=0, state=0x7fffffff11e0) at dominion.c:566
566         if (state->deckCount[player] <= 0) { //Deck is empty
(gdb) s
606             int count = state->handCount[player];//Get current hand count for player
(gdb) s
612             deckCounter = state->deckCount[player];//Create holder for the deck count
(gdb) s
613             state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
(gdb) s
614             state->deckCount[player]--;
(gdb) s
615             state->handCount[player]++;//Increment hand count
(gdb) s
618         return 0;
(gdb) s
619     }
(gdb) p testG.hand[1][0]
No symbol "testG" in current context.
(gdb) s
tributeEffect (state=0x7fffffff11e0, currentPlayer=0, nextPlayer=1)
    at dominion.c:906
906             for (int i = 0; i <= 2; i ++) {
(gdb) s
907                 if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold) { //Treasure cards
(gdb) s
911                 else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall) { //Victory Card Found
(gdb) s
912                     drawCard(currentPlayer, state);
(gdb) s
drawCard (player=0, state=0x7fffffff11e0) at dominion.c:566
566         if (state->deckCount[player] <= 0) { //Deck is empty
(gdb) s
606             int count = state->handCount[player];//Get current hand count for player
(gdb) s
612             deckCounter = state->deckCount[player];//Create holder for the deck count
(gdb) s
613             state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
(gdb) s
614             state->deckCount[player]--;
(gdb) s
615             state->handCount[player]++;//Increment hand count
(gdb) s
618         return 0;
(gdb) p state->discardCount[1]
$8 = 0
(gdb) p state->handCount[1]
$9 = 2
(gdb) s
619     }
(gdb) s
tributeEffect (state=0x7fffffff11e0, currentPlayer=0, nextPlayer=1)
    at dominion.c:913
913                     drawCard(currentPlayer, state);
(gdb) s
drawCard (player=0, state=0x7fffffff11e0) at dominion.c:566
566         if (state->deckCount[player] <= 0) { //Deck is empty
(gdb) s
606             int count = state->handCount[player];//Get current hand count for player
(gdb) s
612             deckCounter = state->deckCount[player];//Create holder for the deck count
(gdb) s
613             state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
(gdb) s
614             state->deckCount[player]--;
(gdb) s
615             state->handCount[player]++;//Increment hand count
(gdb) s
618         return 0;
(gdb) s
619     }
(gdb) s
tributeEffect (state=0x7fffffff11e0, currentPlayer=0, nextPlayer=1)
    at dominion.c:906
s906            for (int i = 0; i <= 2; i ++) {
(gdb) s
s920            return 0;
(gdb) s
921     }
(gdb) s
main () at unittest5.c:62
62          if(assertValues((2+coinsPre),testG.coins))
(gdb) s
assertValues (paramOne=6, paramTwo=6) at unittest5.c:20
20          if(paramOne==paramTwo)
(gdb) s
22              return 1;
(gdb) s
29      }
(gdb) s
main () at unittest5.c:64
64              printf("PASS: Coins was incremented correctly for player 1 after playing tribute and 2 treasure cards revealed\n");
(gdb) s
PASS: Coins was incremented correctly for player 1 after playing tribute and 2 treasure cards revealed
65              printf("coins before tribute  %d\n ",coinsPre);
(gdb) p testG.handCount[1]
$10 = 2
(gdb) p testG.discardCount[1]
$11 = 0
(gdb) s
coins before tribute  4
66              printf("coins after tribute   %d\n\n",testG.coins );
(gdb) s
 coins after tribute   6

76          memcpy (&testG, &G, sizeof(struct gameState));
(gdb) q
A debugging session is active.

        Inferior 1 [process 11293] will be killed.

Quit anyway? (y or n) y
